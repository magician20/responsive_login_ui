// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  InvalidEmail<T> invalidEmail<T>(T? failedValue) {
    return InvalidEmail<T>(
      failedValue,
    );
  }

  InvalidUserName<T> invalidNameAlphabet<T>(T? failedValue) {
    return InvalidUserName<T>(
      failedValue,
    );
  }

  ShortPassword<T> shortPassword<T>(T? failedValue, {int? min}) {
    return ShortPassword<T>(
      failedValue,
      min: min,
    );
  }

  ShortUserName<T> shortUserName<T>(T? failedValue, {int? min}) {
    return ShortUserName<T>(
      failedValue,
      min: min,
    );
  }

  Multiline<T> multiline<T>(T? failedValue) {
    return Multiline<T>(
      failedValue,
    );
  }

  ListTooLong<T> listTooLong<T>(T? failedValue, {int? max}) {
    return ListTooLong<T>(
      failedValue,
      max: max,
    );
  }

  ExceedingLength<T> exceedingLength<T>(T? failedValue, {int? max}) {
    return ExceedingLength<T>(
      failedValue,
      max: max,
    );
  }

  Empty<T> empty<T>(T? failedValue) {
    return Empty<T>(
      failedValue,
    );
  }

  AtLeastOneUpperChar<T> atLeastOneUpperChar<T>(T? failedValue) {
    return AtLeastOneUpperChar<T>(
      failedValue,
    );
  }

  AtLeastOneLowerChar<T> atLeastOneLowerChar<T>(T? failedValue) {
    return AtLeastOneLowerChar<T>(
      failedValue,
    );
  }

  AtLeastOneDigit<T> atLeastOneDigit<T>(T? failedValue) {
    return AtLeastOneDigit<T>(
      failedValue,
    );
  }

  AtLeastOneSpecialChar<T> atLeastOneSpecialChar<T>(T? failedValue) {
    return AtLeastOneSpecialChar<T>(
      failedValue,
    );
  }

  InvalidStatus<T> invalidStatus<T>(T? failedValue) {
    return InvalidStatus<T>(
      failedValue,
    );
  }

  InvalidState<T> invalidState<T>(T? failedValue) {
    return InvalidState<T>(
      failedValue,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T? get failedValue => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T? failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidEmail<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail(T? failedValue) = _$InvalidEmail<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidUserNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidUserNameCopyWith(
          InvalidUserName<T> value, $Res Function(InvalidUserName<T>) then) =
      _$InvalidUserNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$InvalidUserNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUserNameCopyWith<T, $Res> {
  _$InvalidUserNameCopyWithImpl(
      InvalidUserName<T> _value, $Res Function(InvalidUserName<T>) _then)
      : super(_value, (v) => _then(v as InvalidUserName<T>));

  @override
  InvalidUserName<T> get _value => super._value as InvalidUserName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidUserName<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidUserName<T> implements InvalidUserName<T> {
  const _$InvalidUserName(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNameAlphabet(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidUserName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidUserNameCopyWith<T, InvalidUserName<T>> get copyWith =>
      _$InvalidUserNameCopyWithImpl<T, InvalidUserName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return invalidNameAlphabet(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return invalidNameAlphabet?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidNameAlphabet != null) {
      return invalidNameAlphabet(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return invalidNameAlphabet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return invalidNameAlphabet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidNameAlphabet != null) {
      return invalidNameAlphabet(this);
    }
    return orElse();
  }
}

abstract class InvalidUserName<T> implements ValueFailure<T> {
  const factory InvalidUserName(T? failedValue) = _$InvalidUserName<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidUserNameCopyWith<T, InvalidUserName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? min});
}

/// @nodoc
class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword(this.failedValue, {this.min});

  @override
  final T? failedValue;
  @override
  final int? min;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue, min: $min)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ShortPassword<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.min, min));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(min));

  @JsonKey(ignore: true)
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return shortPassword(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return shortPassword?.call(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(failedValue, min);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return shortPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword(T? failedValue, {int? min}) = _$ShortPassword<T>;

  @override
  T? get failedValue;
  int? get min;
  @override
  @JsonKey(ignore: true)
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortUserNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortUserNameCopyWith(
          ShortUserName<T> value, $Res Function(ShortUserName<T>) then) =
      _$ShortUserNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? min});
}

/// @nodoc
class _$ShortUserNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortUserNameCopyWith<T, $Res> {
  _$ShortUserNameCopyWithImpl(
      ShortUserName<T> _value, $Res Function(ShortUserName<T>) _then)
      : super(_value, (v) => _then(v as ShortUserName<T>));

  @override
  ShortUserName<T> get _value => super._value as ShortUserName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = freezed,
  }) {
    return _then(ShortUserName<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ShortUserName<T> implements ShortUserName<T> {
  const _$ShortUserName(this.failedValue, {this.min});

  @override
  final T? failedValue;
  @override
  final int? min;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortUserName(failedValue: $failedValue, min: $min)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ShortUserName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.min, min));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(min));

  @JsonKey(ignore: true)
  @override
  $ShortUserNameCopyWith<T, ShortUserName<T>> get copyWith =>
      _$ShortUserNameCopyWithImpl<T, ShortUserName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return shortUserName(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return shortUserName?.call(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (shortUserName != null) {
      return shortUserName(failedValue, min);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return shortUserName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return shortUserName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (shortUserName != null) {
      return shortUserName(this);
    }
    return orElse();
  }
}

abstract class ShortUserName<T> implements ValueFailure<T> {
  const factory ShortUserName(T? failedValue, {int? min}) = _$ShortUserName<T>;

  @override
  T? get failedValue;
  int? get min;
  @override
  @JsonKey(ignore: true)
  $ShortUserNameCopyWith<T, ShortUserName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MultilineCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $MultilineCopyWith(
          Multiline<T> value, $Res Function(Multiline<T>) then) =
      _$MultilineCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$MultilineCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $MultilineCopyWith<T, $Res> {
  _$MultilineCopyWithImpl(
      Multiline<T> _value, $Res Function(Multiline<T>) _then)
      : super(_value, (v) => _then(v as Multiline<T>));

  @override
  Multiline<T> get _value => super._value as Multiline<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(Multiline<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$Multiline<T> implements Multiline<T> {
  const _$Multiline(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Multiline<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      _$MultilineCopyWithImpl<T, Multiline<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return multiline?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return multiline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ValueFailure<T> {
  const factory Multiline(T? failedValue) = _$Multiline<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListTooLongCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ListTooLongCopyWith(
          ListTooLong<T> value, $Res Function(ListTooLong<T>) then) =
      _$ListTooLongCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? max});
}

/// @nodoc
class _$ListTooLongCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ListTooLongCopyWith<T, $Res> {
  _$ListTooLongCopyWithImpl(
      ListTooLong<T> _value, $Res Function(ListTooLong<T>) _then)
      : super(_value, (v) => _then(v as ListTooLong<T>));

  @override
  ListTooLong<T> get _value => super._value as ListTooLong<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = freezed,
  }) {
    return _then(ListTooLong<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ListTooLong<T> implements ListTooLong<T> {
  const _$ListTooLong(this.failedValue, {this.max});

  @override
  final T? failedValue;
  @override
  final int? max;

  @override
  String toString() {
    return 'ValueFailure<$T>.listTooLong(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ListTooLong<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.max, max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(max));

  @JsonKey(ignore: true)
  @override
  $ListTooLongCopyWith<T, ListTooLong<T>> get copyWith =>
      _$ListTooLongCopyWithImpl<T, ListTooLong<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return listTooLong(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return listTooLong?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return listTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return listTooLong?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(this);
    }
    return orElse();
  }
}

abstract class ListTooLong<T> implements ValueFailure<T> {
  const factory ListTooLong(T? failedValue, {int? max}) = _$ListTooLong<T>;

  @override
  T? get failedValue;
  int? get max;
  @override
  @JsonKey(ignore: true)
  $ListTooLongCopyWith<T, ListTooLong<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExceedingLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ExceedingLengthCopyWith(
          ExceedingLength<T> value, $Res Function(ExceedingLength<T>) then) =
      _$ExceedingLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? max});
}

/// @nodoc
class _$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ExceedingLengthCopyWith<T, $Res> {
  _$ExceedingLengthCopyWithImpl(
      ExceedingLength<T> _value, $Res Function(ExceedingLength<T>) _then)
      : super(_value, (v) => _then(v as ExceedingLength<T>));

  @override
  ExceedingLength<T> get _value => super._value as ExceedingLength<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = freezed,
  }) {
    return _then(ExceedingLength<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength(this.failedValue, {this.max});

  @override
  final T? failedValue;
  @override
  final int? max;

  @override
  String toString() {
    return 'ValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ExceedingLength<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.max, max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(max));

  @JsonKey(ignore: true)
  @override
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      _$ExceedingLengthCopyWithImpl<T, ExceedingLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return exceedingLength?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return exceedingLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength(T? failedValue, {int? max}) =
      _$ExceedingLength<T>;

  @override
  T? get failedValue;
  int? get max;
  @override
  @JsonKey(ignore: true)
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptyCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $EmptyCopyWith(Empty<T> value, $Res Function(Empty<T>) then) =
      _$EmptyCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$EmptyCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $EmptyCopyWith<T, $Res> {
  _$EmptyCopyWithImpl(Empty<T> _value, $Res Function(Empty<T>) _then)
      : super(_value, (v) => _then(v as Empty<T>));

  @override
  Empty<T> get _value => super._value as Empty<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(Empty<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$Empty<T> implements Empty<T> {
  const _$Empty(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Empty<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      _$EmptyCopyWithImpl<T, Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return empty?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty(T? failedValue) = _$Empty<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtLeastOneUpperCharCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $AtLeastOneUpperCharCopyWith(AtLeastOneUpperChar<T> value,
          $Res Function(AtLeastOneUpperChar<T>) then) =
      _$AtLeastOneUpperCharCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$AtLeastOneUpperCharCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $AtLeastOneUpperCharCopyWith<T, $Res> {
  _$AtLeastOneUpperCharCopyWithImpl(AtLeastOneUpperChar<T> _value,
      $Res Function(AtLeastOneUpperChar<T>) _then)
      : super(_value, (v) => _then(v as AtLeastOneUpperChar<T>));

  @override
  AtLeastOneUpperChar<T> get _value => super._value as AtLeastOneUpperChar<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(AtLeastOneUpperChar<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneUpperChar<T> implements AtLeastOneUpperChar<T> {
  const _$AtLeastOneUpperChar(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneUpperChar(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AtLeastOneUpperChar<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $AtLeastOneUpperCharCopyWith<T, AtLeastOneUpperChar<T>> get copyWith =>
      _$AtLeastOneUpperCharCopyWithImpl<T, AtLeastOneUpperChar<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return atLeastOneUpperChar(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return atLeastOneUpperChar?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneUpperChar != null) {
      return atLeastOneUpperChar(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return atLeastOneUpperChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return atLeastOneUpperChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneUpperChar != null) {
      return atLeastOneUpperChar(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneUpperChar<T> implements ValueFailure<T> {
  const factory AtLeastOneUpperChar(T? failedValue) = _$AtLeastOneUpperChar<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $AtLeastOneUpperCharCopyWith<T, AtLeastOneUpperChar<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtLeastOneLowerCharCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $AtLeastOneLowerCharCopyWith(AtLeastOneLowerChar<T> value,
          $Res Function(AtLeastOneLowerChar<T>) then) =
      _$AtLeastOneLowerCharCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$AtLeastOneLowerCharCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $AtLeastOneLowerCharCopyWith<T, $Res> {
  _$AtLeastOneLowerCharCopyWithImpl(AtLeastOneLowerChar<T> _value,
      $Res Function(AtLeastOneLowerChar<T>) _then)
      : super(_value, (v) => _then(v as AtLeastOneLowerChar<T>));

  @override
  AtLeastOneLowerChar<T> get _value => super._value as AtLeastOneLowerChar<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(AtLeastOneLowerChar<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneLowerChar<T> implements AtLeastOneLowerChar<T> {
  const _$AtLeastOneLowerChar(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneLowerChar(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AtLeastOneLowerChar<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $AtLeastOneLowerCharCopyWith<T, AtLeastOneLowerChar<T>> get copyWith =>
      _$AtLeastOneLowerCharCopyWithImpl<T, AtLeastOneLowerChar<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return atLeastOneLowerChar(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return atLeastOneLowerChar?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneLowerChar != null) {
      return atLeastOneLowerChar(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return atLeastOneLowerChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return atLeastOneLowerChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneLowerChar != null) {
      return atLeastOneLowerChar(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneLowerChar<T> implements ValueFailure<T> {
  const factory AtLeastOneLowerChar(T? failedValue) = _$AtLeastOneLowerChar<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $AtLeastOneLowerCharCopyWith<T, AtLeastOneLowerChar<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtLeastOneDigitCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $AtLeastOneDigitCopyWith(
          AtLeastOneDigit<T> value, $Res Function(AtLeastOneDigit<T>) then) =
      _$AtLeastOneDigitCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$AtLeastOneDigitCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $AtLeastOneDigitCopyWith<T, $Res> {
  _$AtLeastOneDigitCopyWithImpl(
      AtLeastOneDigit<T> _value, $Res Function(AtLeastOneDigit<T>) _then)
      : super(_value, (v) => _then(v as AtLeastOneDigit<T>));

  @override
  AtLeastOneDigit<T> get _value => super._value as AtLeastOneDigit<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(AtLeastOneDigit<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneDigit<T> implements AtLeastOneDigit<T> {
  const _$AtLeastOneDigit(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneDigit(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AtLeastOneDigit<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $AtLeastOneDigitCopyWith<T, AtLeastOneDigit<T>> get copyWith =>
      _$AtLeastOneDigitCopyWithImpl<T, AtLeastOneDigit<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return atLeastOneDigit(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return atLeastOneDigit?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneDigit != null) {
      return atLeastOneDigit(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return atLeastOneDigit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return atLeastOneDigit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneDigit != null) {
      return atLeastOneDigit(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneDigit<T> implements ValueFailure<T> {
  const factory AtLeastOneDigit(T? failedValue) = _$AtLeastOneDigit<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $AtLeastOneDigitCopyWith<T, AtLeastOneDigit<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtLeastOneSpecialCharCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $AtLeastOneSpecialCharCopyWith(AtLeastOneSpecialChar<T> value,
          $Res Function(AtLeastOneSpecialChar<T>) then) =
      _$AtLeastOneSpecialCharCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$AtLeastOneSpecialCharCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $AtLeastOneSpecialCharCopyWith<T, $Res> {
  _$AtLeastOneSpecialCharCopyWithImpl(AtLeastOneSpecialChar<T> _value,
      $Res Function(AtLeastOneSpecialChar<T>) _then)
      : super(_value, (v) => _then(v as AtLeastOneSpecialChar<T>));

  @override
  AtLeastOneSpecialChar<T> get _value =>
      super._value as AtLeastOneSpecialChar<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(AtLeastOneSpecialChar<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneSpecialChar<T> implements AtLeastOneSpecialChar<T> {
  const _$AtLeastOneSpecialChar(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneSpecialChar(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AtLeastOneSpecialChar<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $AtLeastOneSpecialCharCopyWith<T, AtLeastOneSpecialChar<T>> get copyWith =>
      _$AtLeastOneSpecialCharCopyWithImpl<T, AtLeastOneSpecialChar<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return atLeastOneSpecialChar(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return atLeastOneSpecialChar?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneSpecialChar != null) {
      return atLeastOneSpecialChar(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return atLeastOneSpecialChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return atLeastOneSpecialChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (atLeastOneSpecialChar != null) {
      return atLeastOneSpecialChar(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneSpecialChar<T> implements ValueFailure<T> {
  const factory AtLeastOneSpecialChar(T? failedValue) =
      _$AtLeastOneSpecialChar<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $AtLeastOneSpecialCharCopyWith<T, AtLeastOneSpecialChar<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidStatusCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidStatusCopyWith(
          InvalidStatus<T> value, $Res Function(InvalidStatus<T>) then) =
      _$InvalidStatusCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$InvalidStatusCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidStatusCopyWith<T, $Res> {
  _$InvalidStatusCopyWithImpl(
      InvalidStatus<T> _value, $Res Function(InvalidStatus<T>) _then)
      : super(_value, (v) => _then(v as InvalidStatus<T>));

  @override
  InvalidStatus<T> get _value => super._value as InvalidStatus<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidStatus<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidStatus<T> implements InvalidStatus<T> {
  const _$InvalidStatus(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidStatus(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidStatus<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidStatusCopyWith<T, InvalidStatus<T>> get copyWith =>
      _$InvalidStatusCopyWithImpl<T, InvalidStatus<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return invalidStatus(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return invalidStatus?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidStatus != null) {
      return invalidStatus(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return invalidStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return invalidStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidStatus != null) {
      return invalidStatus(this);
    }
    return orElse();
  }
}

abstract class InvalidStatus<T> implements ValueFailure<T> {
  const factory InvalidStatus(T? failedValue) = _$InvalidStatus<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidStatusCopyWith<T, InvalidStatus<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidStateCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidStateCopyWith(
          InvalidState<T> value, $Res Function(InvalidState<T>) then) =
      _$InvalidStateCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class _$InvalidStateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidStateCopyWith<T, $Res> {
  _$InvalidStateCopyWithImpl(
      InvalidState<T> _value, $Res Function(InvalidState<T>) _then)
      : super(_value, (v) => _then(v as InvalidState<T>));

  @override
  InvalidState<T> get _value => super._value as InvalidState<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidState<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidState<T> implements InvalidState<T> {
  const _$InvalidState(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidState(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidState<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidStateCopyWith<T, InvalidState<T>> get copyWith =>
      _$InvalidStateCopyWithImpl<T, InvalidState<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidStatus,
    required TResult Function(T? failedValue) invalidState,
  }) {
    return invalidState(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
  }) {
    return invalidState?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidStatus,
    TResult Function(T? failedValue)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidState != null) {
      return invalidState(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidStatus<T> value) invalidStatus,
    required TResult Function(InvalidState<T> value) invalidState,
  }) {
    return invalidState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
  }) {
    return invalidState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidStatus<T> value)? invalidStatus,
    TResult Function(InvalidState<T> value)? invalidState,
    required TResult orElse(),
  }) {
    if (invalidState != null) {
      return invalidState(this);
    }
    return orElse();
  }
}

abstract class InvalidState<T> implements ValueFailure<T> {
  const factory InvalidState(T? failedValue) = _$InvalidState<T>;

  @override
  T? get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidStateCopyWith<T, InvalidState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
